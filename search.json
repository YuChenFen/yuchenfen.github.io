[{"title":"快速幂","date":"2023-01-05T09:24:22.000Z","url":"/2023/01/05/%E5%BF%AB%E9%80%9F%E5%B9%82/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["模板","/tags/%E6%A8%A1%E6%9D%BF/"],["快速幂","/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"]],"categories":[["模板","/categories/%E6%A8%A1%E6%9D%BF/"]],"content":"快速幂就是利用了二进制原理来进行运算 模板 矩阵模板可以用于多次线性变换"},{"title":"二分算法","date":"2023-01-05T09:20:26.000Z","url":"/2023/01/05/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["二分","/tags/%E4%BA%8C%E5%88%86/"],["模板","/tags/%E6%A8%A1%E6%9D%BF/"]],"categories":[["模板","/categories/%E6%A8%A1%E6%9D%BF/"]],"content":"二分模板 算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 模板一将区间划分为 [l , mid] 和 [mid + 1 , r] , 这时候只要更新 l = mid + 1 或者 r = mid ， mid 不需要加一 模板二将区间划分为 [l , mid - 1] 和 [mid , r] , 这时候只要更新 l = mid 或者 r = mid - 1 ， 为了防止死循环，mid 需要加一 "},{"title":"并查集","date":"2023-01-05T08:36:21.000Z","url":"/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["python","/tags/python/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"并查集并查集是一种树形的数据结构，用于处理一些不相交的合并与查询问题。 例如： 有n个元素，分属不同的n个集合: 主要有两种操作，一种是合并，另一个就是查询: x 和 y 合并：将 x 和 y 的集合合并成一个大集合查询 x~i~ 和 y~i~ 是否在同一个集合查询 1 ，2 返回 true 。查询 1 ，4 返回 false。 首先用数组存储这样的数据，需要传入一个数据数量。开始的父结点都是自己接着定义一个查找父结点的方法(私有)压缩路径：在遍历的过程中尽量将该节点的数值直接定义为根节点，这样可以使下一次查找更方便接着定义一个合并集合的方法,就将A的父结点的父结点设置为B的父结点还有一个查询方法，如果A ，B 两个父结点相同证明在同一个集合，反之则不在同一个集合完整代码 带权并查集如果两个节点之间存在某种关系，则需要一个能维护这种关系的并查集与普通的并查集不同的是它们之间存在着某种关系，可以用一个 re 数组来记录当前节点和父结点的关系。压缩路径时将节点的权值更新，更新时可以用向量法来解决所以在查找父结点时更新路径加上re[a] = re[a] + re[b]就可以了合并时将节点的权值加上即可，具体方法还是用向量查找不变如果要分类，加上一个mod（分类数目）就可以了"},{"title":"背包问题","date":"2023-01-05T07:52:09.000Z","url":"/2023/01/05/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","tags":[["python","/tags/python/"],["背包问题","/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":" 背包问题 01背包 方法 空间优化 完全背包 方法 空间优化 多重背包 方法 二进制优化 单调队列优化 背包问题01背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为w~i~，价值为p~i~，每种物品只有一个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 方法定义dp[i][j] : 表示第i件物品，在j的容量下能获得的最大价值。 对于每个物品，有两种选择：要么将他装进背包，要么将他舍去。那么可以划分为两种集合因为是要最大价值所以取集合的max 一轮表示第 k 件物品的选择 如果不选择物品 i，则是上一轮容量为 j 的最大价值，相当于无事发生 如果选择物品 i， 则是上一轮容量为 j - w 的最大价值加上当前物品的价值 p （因为要放下该物品需要 w 的空间， 所以需要：当前空间 - w的最大价值） dp存储的是最大价值，所以我们需要选择两者的最大值作为当前位置的数值，即在第i个物品，在容量为j下的最大价值 转移方程 : 空间优化除此之外，还可以对空间进行优化： 先来看看转移方程对于更新物品 i 的值只与物品 i - 1 有关，可以用一个滚动数组进行优化。对于容量 j 只与上一层的容量 j 和 j - w 有关，也就意味着 小容量可以影响大容量的值，即如果先更新小容量 j - w ，那么上一层容量为 j - w 的最大价值就会丢失。所以需要先更新大的值在更新小的值。 完全背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为w~i~，价值为p~i~，每种物品有无数个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 与 01 背包的差别在于物品有无数个 方法定义dp[i][j] : 表示第i件物品，在j的容量下能获得的最大价值。 对于第 i 个物品我们有很多选择，要么不选，要么选 1 ，2 ，3 ，… , k , … 个,划分集合：因为是要最大价值所以取集合的max 转移方程来看看 $dp[i][j]$在看看dp[i][j - w] (其实就是吧 j 换成 j - w)现在将它们放到一起看看可以发现两者非常相近，dp[i][j -w] + p 和 上面的数据一样，将这些部分替换掉就可以得到 (哎呀，就把01背包中的dp[i - 1][j - w[i]] + p[i] 换成 dp[i][j - w[i]] + p[i]) 空间优化跟01背包一样可以进行空间优化，还是用一个滚动数组来存储数据 看看转移方程： 对于物品 i ,是 dp[i][j - w] 影响着 dp[i][j] ，即本层应该先更新 dp[i][j - w] 在更新 dp[i][j]，也就是得从小到大进行更新 (其实跟01背包的完全一样，只是更新顺序不一样) (将01背包的for循环由从大到小改为从小到大，即j—改为j++） 多重背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为w~i~，价值为p~i~，每种物品有s~i~个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 方法这个问题可以转换为$01$背包问题来解决，其中转移方程就是 dp[i]表示在当前物品之前容量为 i 的情况下能获得的最大价值 二进制优化先来看看一个数可以怎样表示，比如说13，他可以用1，2，4，6来表示(当然还可以用其他方式，比如说一个1代表1，两个1代表2，…，13个1代表13，但我们需要用尽可能少的数字来表示它)。 $\\begin{array}{l}1 = 1\\2 = 2\\3 = 1 + 2\\4 = 4\\5 = 1 + 4\\6 = 2 + 4\\7 = 1 + 2 + 4\\8 = 2 + 6\\9 = 1 + 2 + 6\\10 = 4 + 6\\11 = 1 + 4 + 6\\12 = 2 + 4 + 6\\13 = 1 + 2 + 4 + 6\\end{array}$ 那是怎样拆分出1，2，4，6的呢，首先来回顾一下二进制 (15)~10~ = (1111)~2~ ,那就可以用1，2，4，8表示就可以表示0到15的数了，但(13)~10~ = (1101)~2~不能用1，4，8来表示(比如表示2)。 那怎么进行二进制拆分呢 这样我们就将13拆分成1，2，4，6。接着将物品 i 以 1，2，4，6 的数量来进行拆分在加上01背包的思路就是完整的了 单调队列优化我们看看如何用单调队列来优化这个代码，我们重新分析这个问题： 对于物品的取值： 有$dp[i] = max\\left { dp[i],dp[i-kw_{i}] + kp{i} \\right }(k*w{i}&lt;=V,k&lt;=s_{i})$我们可以将一些v提出来，变成这时我们可以发现有很多相同的量我们需要找出他们的最大值 首先来看看如何找出dp[j]，可以发现j,j+w,j+2w模上m后都等于j这时可以列出下表，行是一类数据，列是同模的数据dp[0]|dp[1]|dp[2]|…|dp[w-1]-|-|-|-|-dp[0+w]|dp[1+w]|dp[2+w]|…|dp[(w-1)+w]dp[0+2w]|dp[1+2w]|dp[2+2w]|…|dp[(w-1)+2w]dp[0+3w]|dp[1+3w]|dp[2+3w]|…|dp[(w-1)+3w]…|…|…|…|…dp[0+kw]|dp[1+kw]|dp[2+kw]|…|dp[(w-1)+kw] dp[j] 则是 dp[0]~dp[w-1],如果要问为什么是w-1，那就是一个数模上w必定小于w 如果找的是j ~ j+kw 的最大值那就是完全背包的问题，因为物品的数量有限，所以我们要从j ~ j + sw找最大值，从j + w ~ j + (s+1)w的最大值.所以我们需要维护一个大小为s的滑动窗口（单调队列）来存储当前区间的最大值。 关于上面的变量解释queue|start|end|k|w|p|j|dp|dp_old-|-|-|-|-|-|-|-|-队列|队头|队尾|当前位置|物品体积|物品价值|同余数|当前轮的数据|上一轮的数据对于end &gt;= start是队尾一定要在队头后面开始的时候end指向的是一个空位置，当有数据加入时end++ 在将数据填入queue，即： $1$$2$$3$当有数据移除是start++这样就实现了一个双端队列 接着我们需要把数据存入这样一个队列，原则是这个队列必须是单调的，即 queue[i] &gt; queue[i-1] 或 queue[i] &gt; queue[i-1]现在来考虑如何出队。 我们需要维护一个大小固定的队列，即当前队头的位置不在维护的窗口时，我们就将队头的元素出队，即：调整一下，就变成当满足这个式子时start++，即从队头出队。 添加元素 我们需要维护这个队列的单调性，这入队时需要考虑队尾元素是否与我们入队的元素大小关系 如果是单调递增则(队尾 &gt;= 入队),则弹出队尾元素，直到不满足为止 如果是单调递减则(队尾 &lt;= 入队),则弹出队尾元素，直到不满足为止 看看队列里需要存的值需要存的是下标最大值，则需要用到单调递减的单调队列 如何将数据加入到队列中（存储下标，即j+kw）也就是将 dp[j+kw] - kp 加入，当队尾 dp[queue[end]] - (queue[end] - j) / w p &lt;= dp[k] - (k - j) / w p 时（这里的dp是上一轮的数据）,弹出元素，直到满足为止，在把元素加入队列中 接着考虑如何更新，在来看看dp是如何更新的：那也就是"},{"title":"最小表示法","date":"2023-01-04T04:55:27.000Z","url":"/2023/01/04/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["python","/tags/python/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"最小表示法 "}]