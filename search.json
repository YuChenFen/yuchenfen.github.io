[{"title":"背包问题","date":"2023-01-05T07:52:09.000Z","url":"/2023/01/05/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","tags":[["python","/tags/python/"],["背包问题","/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"]],"categories":[["undefined",""]],"content":" 背包问题 01背包 方法 空间优化 完全背包 方法 空间优化 多重背包 方法 二进制优化 单调队列优化 背包问题01背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为w~i~，价值为p~i~，每种物品只有一个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 方法定义dp[i][j] : 表示第i件物品，在j的容量下能获得的最大价值。 对于每个物品，有两种选择：要么将他装进背包，要么将他舍去。那么可以划分为两种集合因为是要最大价值所以取集合的max 一轮表示第 k 件物品的选择 如果不选择物品 i，则是上一轮容量为 j 的最大价值，相当于无事发生 如果选择物品 i， 则是上一轮容量为 j - w 的最大价值加上当前物品的价值 p （因为要放下该物品需要 w 的空间， 所以需要：当前空间 - w的最大价值） dp存储的是最大价值，所以我们需要选择两者的最大值作为当前位置的数值，即在第i个物品，在容量为j下的最大价值 转移方程 : dp[i][j] = max(dp[i-1][j] , dp[i-1][j - w_{i}] + p_{i})(j >= w_{i}) 空间优化除此之外，还可以对空间进行优化： 先来看看转移方程 dp[i][j] = max(dp[i-1][j] , dp[i-1][j - w_{i}] + p_{i})(j >= w_{i})对于更新物品 i 的值只与物品 i - 1 有关，可以用一个滚动数组进行优化。 dp[j] = max(dp[j] , dp[j - w_{i}] + p_{i})(j >= w_{i})对于容量 j 只与上一层的容量 j 和 j - w 有关，也就意味着 小容量可以影响大容量的值，即如果先更新小容量 j - w ，那么上一层容量为 j - w 的最大价值就会丢失。所以需要先更新大的值在更新小的值。 完全背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为w~i~，价值为p~i~，每种物品有无数个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 与 01 背包的差别在于物品有无数个 方法定义dp[i][j] : 表示第i件物品，在j的容量下能获得的最大价值。 对于第 i 个物品我们有很多选择，要么不选，要么选 1 ，2 ，3 ，… , k , … 个,划分集合：因为是要最大价值所以取集合的max 转移方程 dp[i][j] = max(dp[i-1][j] , dp[i-1][j - k*w_{i}] + k*p_{i})(j >= k*w_{i})来看看 $dp[i][j]$在看看dp[i][j - w] (其实就是吧 j 换成 j - w)现在将它们放到一起看看可以发现两者非常相近，dp[i][j -w] + p 和 上面的数据一样，将这些部分替换掉就可以得到 dp[i][j] = max(dp[i - 1][j],dp[i][j - w] + p) (哎呀，就把01背包中的dp[i - 1][j - w[i]] + p[i] 换成 dp[i][j - w[i]] + p[i]) 空间优化跟01背包一样可以进行空间优化，还是用一个滚动数组来存储数据 看看转移方程： dp[i][j] = max(dp[i - 1][j],dp[i][j - w] + p)对于物品 i ,是 dp[i][j - w] 影响着 dp[i][j] ，即本层应该先更新 dp[i][j - w] 在更新 dp[i][j]，也就是得从小到大进行更新 dp[j] = max(dp[j] , dp[j - w_{i}] + p_{i})(j >= w_{i})(其实跟01背包的完全一样，只是更新顺序不一样) (将01背包的for循环由从大到小改为从小到大，即j—改为j++） 多重背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为w~i~，价值为p~i~，每种物品有s~i~个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 方法这个问题可以转换为$01$背包问题来解决，其中转移方程就是 dp[i] = max\\left \\{ dp[i],dp[i-k*m_{i}] + k*v_{i} \\right \\}(k*m_{i}"},{"title":"最小表示法","date":"2023-01-04T04:55:27.000Z","url":"/2023/01/04/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["python","/tags/python/"]],"categories":[["undefined",""]],"content":"最小表示法"}]