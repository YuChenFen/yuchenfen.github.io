[{"title":"vue学习记录","date":"2023-01-07T04:15:59.000Z","url":"/2023/01/07/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["vue","/tags/vue/"],["学习记录","/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":" f6066fc578b6fe5c4912c62c3210122c45600fa2948d20c792cd309998874985cdf4f8986f650ddeb9395250f289cd70 您好，这里需要密码。 "},{"title":"树状数组","date":"2023-01-06T03:11:27.000Z","url":"/2023/01/06/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["数据结构","/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"树状数组用于快速查找和修改 lowbit查找最低位1的位置 区域查询查询 0 ~ idx 数据的和 单点更新更新 idx 的值为 val code"},{"title":"最小生成树","date":"2023-01-06T02:55:33.000Z","url":"/2023/01/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["最小生成树","/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"最小生成树连通图所有生成树之中边权之和最小的生成树使用邻接矩阵来存储图 prim算法从已知的点开始向外扩散，寻找最小的邻边，将顶点加入集合，已加入集合的点不能在加入，直到所有顶点加入到集合当中，构成最小生成树。 从任意一个节点开始，将连通图划分为两个区域，一个是选中的，另一个是未选中的。每次选取选中的点当中连到未选中点的边权最小值，直到每个顶点被选中。 采用3个列表selected、minDist、parent，分别来记录：该节点是否被选中、当前节点连接顶点的边权最小值、将当前顶点连接到哪个顶点上。初始化为 . 0 1 2 3 4 5 selected false false false false false false minDist inf inf inf inf inf inf parent -1 -1 -1 -1 -1 -1 接着将选中顶点的边权录入列表内 . 0 1 2 3 4 5 selected true false false false false false minDist inf 2 inf 4 inf inf parent -1 0 -1 0 -1 -1 然后遍历minDis找出没选过点(即selected为false的点)最小的边(这里是1)，将他加入集合内，用selected记录，更新minDist和parent选中的selected更新为true,minDist更新为inf(这步可以省略) . 0 1 2 3 4 5 selected true true false false false false minDist inf inf inf 4 inf inf parent -1 0 -1 0 -1 -1 在将刚刚加入的点的边进行更新，如果小于当前值且未加入集合就进行赋值 . 0 1 2 3 4 5 selected true true false false false false minDist inf inf 2 1 inf inf parent -1 0 1 1 -1 -1 重复更新选点的操作直到每个点被选中。 以下是完整代码 kruskal算法与prim算法不同，kruskal算法则是由边出发，每次选取权值最小的边 将每个边加入到列表中，按权值排好序后由小到大遍历列表，如果边所连接的两个顶点未在同一个集合，就将两个集合合并，并选取该边，这里需要用到并查集。列表： 权值 1 2 2 3 4 4 5 8 顶点1 4 0 1 3 0 2 3 4 顶点2 5 1 2 5 5 4 2 5 循环列表直到结束 完整代码"},{"title":"最短路径","date":"2023-01-06T02:53:18.000Z","url":"/2023/01/06/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["最短路径","/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"最短路径问题求一个图的最短路径。 示例用邻接矩阵来存储图 n表示大小,maxNum表示无穷,array表示图 BFS(广度优先搜索)算法 (无权图、单源最短路)广度优先搜索主要用于求解无权图或者等权图的最短路径，主要由一个点向外扩散，第一次到达的路径就是源点到达该点的最短路径。 其过程就是用一个表(table)来存储每个节点的访问情况，初始化时将一个顶点加入队列(queue)。 将队头取出,将它在表(table)内的状态设置为True(表示已经访问过),将它未访问的邻点加入队列(queue),循环该过程，直到每个顶点都被访问过了。 返回的是startPoint到各个顶点的最短距离 Dijkstra算法 (带权图、无权图、无负权、单源最短路)与prim算法差不多，prim是到集合的距离，而Dijkstra是到某个点的距离这里不做过多叙述，可以参考最小生成树的prim算法 dellman-ford算法(带权图、无权图、单源最短路) Floyd算法 (带权图、无权图、无负环、各个顶点之间的最短路径)用一个新的数组来记录当前状态: graph(i,j):表示从i到j的最短距离 graph(i,j) = min(graph(i,j) , graph(i,k) + graph(k,j)):表示从i -&gt; k -&gt; j 这条路比 i -&gt; j 这条路短 "},{"title":"快速幂","date":"2023-01-05T09:24:22.000Z","url":"/2023/01/05/%E5%BF%AB%E9%80%9F%E5%B9%82/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["模板","/tags/%E6%A8%A1%E6%9D%BF/"],["快速幂","/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"]],"categories":[["模板","/categories/%E6%A8%A1%E6%9D%BF/"]],"content":"快速幂就是利用了二进制原理来进行运算 模板 矩阵模板可以用于多次线性变换"},{"title":"二分算法","date":"2023-01-05T09:20:26.000Z","url":"/2023/01/05/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/","tags":[["二分","/tags/%E4%BA%8C%E5%88%86/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["模板","/tags/%E6%A8%A1%E6%9D%BF/"]],"categories":[["模板","/categories/%E6%A8%A1%E6%9D%BF/"]],"content":"二分模板 算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 模板一将区间划分为 [l , mid] 和 [mid + 1 , r] , 这时候只要更新 l = mid + 1 或者 r = mid ， mid 不需要加一 模板二将区间划分为 [l , mid - 1] 和 [mid , r] , 这时候只要更新 l = mid 或者 r = mid - 1 ， 为了防止死循环，mid 需要加一 "},{"title":"并查集","date":"2023-01-05T08:36:21.000Z","url":"/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["python","/tags/python/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"并查集 并查集是一种树形的数据结构，用于处理一些不相交的合并与查询问题。 例如： 有n个元素，分属不同的n个集合: 主要有两种操作，一种是合并，另一个就是查询: x 和 y 合并：将 x 和 y 的集合合并成一个大集合 查询 xi 和 yi 是否在同一个集合 查询 1 ，2 返回 true 。查询 1 ，4 返回 false。 首先用数组存储这样的数据，需要传入一个数据数量。开始的父结点都是自己 接着定义一个查找父结点的方法(私有) 压缩路径：在遍历的过程中尽量将该节点的数值直接定义为根节点，这样可以使下一次查找更方便 接着定义一个合并集合的方法,就将A的父结点的父结点设置为B的父结点 还有一个查询方法，如果A ，B 两个父结点相同证明在同一个集合，反之则不在同一个集合 完整代码 带权并查集 如果两个节点之间存在某种关系，则需要一个能维护这种关系的并查集 与普通的并查集不同的是它们之间存在着某种关系，可以用一个 re 数组来记录当前节点和父结点的关系。 压缩路径时将节点的权值更新，更新时可以用向量法来解决 所以在查找父结点时更新路径加上re[a] = re[a] + re[b]就可以了 合并时将节点的权值加上即可，具体方法还是用向量 查找不变 如果要分类，加上一个mod（分类数目）就可以了 "},{"title":"背包问题","date":"2023-01-05T07:52:09.000Z","url":"/2023/01/05/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","tags":[["python","/tags/python/"],["背包问题","/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":" 背包问题 01背包 方法 空间优化 完全背包 方法 空间优化 多重背包 方法 二进制优化 单调队列优化 背包问题 01背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为wi，价值为pi，每种物品只有一个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 方法 定义dp[i][j] : 表示第i件物品，在j的容量下能获得的最大价值。 对于每个物品，有两种选择：要么将他装进背包，要么将他舍去。那么可以划分为两种集合 因为是要最大价值所以取集合的max 一轮表示第 k 件物品的选择 如果不选择物品 i，则是上一轮容量为 j 的最大价值，相当于无事发生 如果选择物品 i， 则是上一轮容量为 j - w 的最大价值加上当前物品的价值 p （因为要放下该物品需要 w 的空间， 所以需要：当前空间 - w的最大价值） dp存储的是最大价值，所以我们需要选择两者的最大值作为当前位置的数值，即在第i个物品，在容量为j下的最大价值 转移方程 : 空间优化 除此之外，还可以对空间进行优化： 先来看看转移方程 对于更新物品 i 的值只与物品 i - 1 有关，可以用一个滚动数组进行优化。 对于容量 j 只与上一层的容量 j 和 j - w 有关，也就意味着 小容量可以影响大容量的值，即如果先更新小容量 j - w ，那么上一层容量为 j - w 的最大价值就会丢失。所以需要先更新大的值在更新小的值。 完全背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为wi，价值为pi，每种物品有无数个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 与 01 背包的差别在于物品有无数个 方法 定义dp[i][j] : 表示第i件物品，在j的容量下能获得的最大价值。 对于第 i 个物品我们有很多选择，要么不选，要么选 1 ，2 ，3 ，… , k , … 个,划分集合： 因为是要最大价值所以取集合的max 转移方程 来看看 dp[i][j] 在看看 dp[i][j - w] (其实就是吧 j 换成 j - w) 现在将它们放到一起看看 可以发现两者非常相近，dp[i][j -w] + p 和 上面的数据一样，将这些部分替换掉就可以得到 (哎呀，就把01背包中的dp[i - 1][j - w[i]] + p[i] 换成 dp[i][j - w[i]] + p[i]) 空间优化 跟01背包一样可以进行空间优化，还是用一个滚动数组来存储数据 看看转移方程： 对于物品 i ,是 dp[i][j - w] 影响着 dp[i][j] ，即本层应该先更新 dp[i][j - w] 在更新 dp[i][j]，也就是得从小到大进行更新 (其实跟01背包的完全一样，只是更新顺序不一样) (将01背包的for循环由从大到小改为从小到大，即j–改为j++） 多重背包 有 n 种物品和一个大小为V的背包。 其中第i种物品的体积为wi，价值为pi，每种物品有si个， 现将一些物品放入背包，在不超过背包容量的情况下，获得物品价值总和最大。 方法 这个问题可以转换为背包问题来解决，其中转移方程就是 dp[i]表示在当前物品之前容量为 i 的情况下能获得的最大价值 二进制优化 先来看看一个数可以怎样表示，比如说13，他可以用1，2，4，6来表示(当然还可以用其他方式，比如说一个1代表1，两个1代表2，…，13个1代表13，但我们需要用尽可能少的数字来表示它)。 那是怎样拆分出1，2，4，6的呢，首先来回顾一下二进制 (15)10 = (1111)2 ,那就可以用1，2，4，8表示就可以表示0到15的数了，但(13)10 = (1101)2不能用1，4，8来表示(比如表示2)。 那怎么进行二进制拆分呢 小于就取自己） 这样我们就将13拆分成1，2，4，6。接着将物品 i 以 1，2，4，6 的数量来进行拆分 在加上01背包的思路就是完整的了 单调队列优化 我们看看如何用单调队列来优化这个代码，我们重新分析这个问题： 对于物品的取值： 有 我们可以将一些v提出来，变成 这时我们可以发现有很多相同的量 我们需要找出他们的最大值 首先来看看如何找出dp[j]，可以发现j,j+w,j+2w模上m后都等于j 这时可以列出下表，行是一类数据，列是同模的数据 dp[0] dp[1] dp[2] … dp[w-1] dp[0+w] dp[1+w] dp[2+w] … dp[(w-1)+w] dp[0+2w] dp[1+2w] dp[2+2w] … dp[(w-1)+2w] dp[0+3w] dp[1+3w] dp[2+3w] … dp[(w-1)+3w] … … … … … dp[0+kw] dp[1+kw] dp[2+kw] … dp[(w-1)+kw] dp[j] 则是 dp[0]~dp[w-1],如果要问为什么是w-1，那就是一个数模上w必定小于w 如果找的是j ~ j+kw 的最大值那就是完全背包的问题，因为物品的数量有限，所以我们要从j ~ j + sw找最大值，从j + w ~ j + (s+1)w的最大值.所以我们需要维护一个大小为s的滑动窗口（单调队列）来存储当前区间的最大值。 关于上面的变量解释 queue start end k w p j dp dp_old 队列 队头 队尾 当前位置 物品体积 物品价值 同余数 当前轮的数据 上一轮的数据 对于end &gt;= start是队尾一定要在队头后面 开始的时候end指向的是一个空位置，当有数据加入时end++ 在将数据填入queue ，即： 当有数据移除是start++ 这样就实现了一个双端队列 接着我们需要把数据存入这样一个队列，原则是这个队列必须是单调的，即 queue[i] &gt; queue[i-1] 或 queue[i] &gt; queue[i-1] 现在来考虑如何出队。 我们需要维护一个大小固定的队列，即当前队头的位置不在维护的窗口时，我们就将队头的元素出队，即： 调整一下，就变成 当满足这个式子时start++，即从队头出队。 添加元素 我们需要维护这个队列的单调性，这入队时需要考虑队尾元素是否与我们入队的元素大小关系 如果是单调递增则(队尾 &gt;= 入队),则弹出队尾元素，直到不满足为止 如果是单调递减则(队尾 &lt;= 入队),则弹出队尾元素，直到不满足为止 看看队列里需要存的值 需要存的是下标最大值，则需要用到单调递减的单调队列 如何将数据加入到队列中（存储下标，即j+kw）也就是将 dp[j+kw] - kp 加入，当队尾 dp[queue[end]] - (queue[end] - j) / w * p &lt;= dp[k] - (k - j) / w * p 时（这里的dp是上一轮的数据）,弹出元素，直到满足为止，在把元素加入队列中 接着考虑如何更新，在来看看dp是如何更新的： 当前 那也就是 当前 dp[j+kw]=max(dp[j+kw],olddp[queue[start]]−(queue[start]−j)/w∗p+(K−j)/w∗p) "},{"title":"最小表示法","date":"2023-01-04T04:55:27.000Z","url":"/2023/01/04/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["python","/tags/python/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"最小表示法 一个字符串的字典序最小表示 先复制一遍字符串添加在后面(字符串环的操作) 初始化 , 用来表示当前能表示字典序最小的开始下标当 与 不相等时 替换较大的那个 即 或 循环到最后选出,最小值即为最小表示法的开始坐标即为 "}]